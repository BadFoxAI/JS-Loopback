
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>JS-Loopback Console</title>
    <!-- ABSOLUTELY NO CSS -->
</head>
<body>
    <!-- Container for the application or system being tested -->
    <h1>Application Being Tested (Pure Raw View)</h1>
    <div id="system-under-test-ui-container">
        <p>Target System UI Placeholder:</p>
        <div id="calculator-display">Calc Val: 0</div>
    </div>
    <hr>

    <!-- Button to toggle the visibility of the diagnostic console -->
    <button id="toggle-diagnostic-console-visibility-button">Toggle Console</button>
    <hr>

    <!-- Root container for the entire diagnostic console -->
    <div id="diagnostic-console-root">
        <h3>JS-Loopback Diagnostic Console</h3>
        
        <!-- Tab buttons to switch between different console tools -->
        <div id="console-tool-tabs-area">
            <button id="show-inspector-pane-button" data-tool="inspector">Inspector Tab</button>
            <button id="show-cli-pane-button" data-tool="cli">CLI Tab</button>
            <button id="show-tests-pane-button" data-tool="tests">Tests Tab</button>
            <button id="show-syslog-pane-button" data-tool="syslog">System Log Tab</button>
        </div>

        <!-- Content area for the active console tool's UI -->
        <div id="console-tool-content-area">
            <!-- Inspector Pane: Allows browsing the target system's object structure -->
            <div id="inspector-pane-raw" class="tool-pane-raw">
                <h4>Inspector Area</h4>
                <button id="refresh-inspector-raw-button">Refresh Inspector</button>
                <div id="object-inspector-output-raw">Inspector output...</div>
            </div>
            <!-- CLI Pane: Allows executing commands on the target system -->
            <div id="cli-pane-raw" class="tool-pane-raw">
                <h4>CLI Area</h4>
                <div id="cli-output-raw">CLI output...</div>
                <div id="cli-input-container-raw">
                    <input type="text" id="cli-input-raw" placeholder='system.add(10)'>
                    <button id="cli-execute-raw-button">Execute</button>
                </div>
            </div>
            <!-- Tests Pane: Allows running predefined self-checks and target system tests -->
            <div id="tests-pane-raw" class="tool-pane-raw">
                <h4>Tests Area</h4>
                <div id="console-controls-area">
                    <button id="run-core-self-check-button">Run Core Self-Check</button>
                    <button id="run-target-system-tests-button">Run Target System Tests</button>
                    <button id="copy-report-button">Copy Report</button> 
                </div>
                <div id="console-test-report-area">Report will appear here...</div>
            </div>
            <!-- System Log Pane: Captures and displays console.log/warn/error messages -->
            <div id="syslog-pane-raw" class="tool-pane-raw">
                <h4>System Console Log Capture</h4>
                <button id="copy-syslog-button">Copy System Log</button>
                <button id="clear-syslog-button">Clear System Log</button>
                <div id="syslog-output-raw" style="font-family: monospace; font-size: 0.9em;">Captured system console logs will appear here...</div>
            </div>
        </div>
    </div>

    <script>
    /**
     * @file RawCoreTester - In-Browser Diagnostic Console
     *
     * This script implements `RawCoreTester`, a JavaScript class that provides an in-browser
     * diagnostic console for web applications. It is designed to be embedded directly into
     * an HTML page without external CSS dependencies, offering a "raw" view suitable for
     * environments with limited styling capabilities or for focused debugging.
     *
     * Core Features:
     * 1.  Object Inspector: Allows developers to browse the properties and methods of a
     *     target JavaScript object (the "system under test"). It renders a navigable tree
     *     structure, handling nested objects, arrays, functions, and circular references.
     * 2.  Command Line Interface (CLI): Provides an input field to execute commands directly
     *     on the target system, such as calling methods or accessing properties.
     *     Supports basic argument parsing for numbers, strings, booleans, and null.
     * 3.  Test Runner: Facilitates the definition and execution of JavaScript-based tests.
     *     It supports both "self-check" tests (for the console itself) and "target system"
     *     tests. Results are displayed in a dedicated report area.
     * 4.  System Log Capture: Overrides native `console.log/warn/error/info/debug` methods
     *     to capture all console output generated by the application and the diagnostic
     *     console. These logs are displayed in a dedicated tab and can be copied.
     * 5.  Minimal UI: The console's UI is constructed with basic HTML elements and minimal
     *     inline styling for core structure, adhering to a "no external CSS" philosophy.
     *
     * Intended Use:
     * -   Debugging JavaScript applications in constrained environments.
     * -   Providing a lightweight, embeddable testing and inspection tool.
     * -   Facilitating remote debugging or diagnostics where standard developer tools
     *     are unavailable or inconvenient.
     *
     * For an LLM:
     * -   This class is instantiated with a `targetSystemInstance`, which is the primary
     *     object the console will interact with (inspect, execute commands on, test).
     * -   The console's UI elements are identified by specific HTML IDs.
     * -   Test definitions (`defineTest`) follow a simple structure: name, array of
     *     asynchronous step functions, criticality, and type (selfCheck/target).
     * -   The console override mechanism (`_overrideConsoleMethods`) is a key aspect for
     *     understanding how system-wide logs are captured.
     * -   The system is designed to be self-contained within this single script and its
     *     corresponding HTML structure.
     */

    class RawCoreTester {
        /**
         * Initializes the RawCoreTester diagnostic console.
         * @param {object} targetSystemInstance - The primary JavaScript object to be inspected and interacted with.
         * @param {string} reportElementId - The ID of the HTML element where test reports will be displayed.
         * @param {object} [options={}] - Configuration options for the console.
         * @param {boolean} [options.initialConsoleVisible=true] - Whether the console is visible on load.
         * @param {string} [options.visibilityToggleKeystroke='Control+Backquote'] - Keystroke to toggle console visibility.
         * @param {string} [options.defaultTool='inspector'] - The tool pane to show by default ('inspector', 'cli', 'tests', 'syslog').
         * @param {number} [options.inspectorMaxDepth=3] - Maximum depth for object inspection.
         * @param {number} [options.maxCapturedLogs=200] - Maximum number of console messages to retain in the System Log.
         */
        constructor(targetSystemInstance, reportElementId, options = {}) {
            // Native console log, will appear in browser dev tools before override fully takes effect for this specific message.
            // Subsequent console calls within this constructor will be captured.
            this._originalConsoleForBootstrap = console.log.bind(console); 
            this._originalConsoleForBootstrap("RawCoreTester: Constructor initiated.");

            this._isInitialized = false; 
            this.targetSystemUnderTest = targetSystemInstance;
            this.reportElement = document.getElementById(reportElementId);

            this._capturedConsoleLogs = [];
            this._originalConsole = {};
            this._overrideConsoleMethods(); // Override console methods early to capture subsequent logs.

            if (!this.reportElement) {
                console.error("RawCoreTester FATAL: Report element not found. ID:", reportElementId);
                const errP = document.createElement('p'); errP.textContent = `RawCoreTester FATAL: Report element with ID '${reportElementId}' missing.`; 
                const consoleRootPlaceholder = document.getElementById('diagnostic-console-root') || document.body;
                if (consoleRootPlaceholder && consoleRootPlaceholder.parentNode) { consoleRootPlaceholder.parentNode.insertBefore(errP, consoleRootPlaceholder); } 
                else { document.body.appendChild(errP); }
                return;
            }
            this.initialReportPlaceholder = 'RawCoreTester Initialized.\nReport will appear here...';
            this.reportElement.textContent = this.initialReportPlaceholder;

            this.options = {
                initialConsoleVisible: true,
                visibilityToggleKeystroke: 'Control+Backquote',
                defaultTool: 'inspector', 
                inspectorMaxDepth: 3,
                maxCapturedLogs: 200,    
                ...options 
            };

            this.tests = []; this.selfCheckTests = []; 
            // Cache references to all necessary DOM elements for the console UI.
            this.consoleRootElement = document.getElementById('diagnostic-console-root');
            this.visibilityToggleButton = document.getElementById('toggle-diagnostic-console-visibility-button');
            this.runCoreSelfCheckButton = document.getElementById('run-core-self-check-button');
            this.runTargetSystemTestsButton = document.getElementById('run-target-system-tests-button');
            this.copyReportButton = document.getElementById('copy-report-button');
            
            this.toolTabButtons = { 
                inspector: document.getElementById('show-inspector-pane-button'), 
                cli: document.getElementById('show-cli-pane-button'), 
                tests: document.getElementById('show-tests-pane-button'),
                syslog: document.getElementById('show-syslog-pane-button') 
            };
            this.toolPanes = { 
                inspector: document.getElementById('inspector-pane-raw'), 
                cli: document.getElementById('cli-pane-raw'), 
                tests: document.getElementById('tests-pane-raw'),
                syslog: document.getElementById('syslog-pane-raw')
            };

            this.cliInputElement = document.getElementById('cli-input-raw');
            this.cliExecuteButton = document.getElementById('cli-execute-raw-button');
            this.cliOutputElement = document.getElementById('cli-output-raw');
            this.refreshInspectorButton = document.getElementById('refresh-inspector-raw-button');
            this.inspectorOutputElement = document.getElementById('object-inspector-output-raw');
            
            this.syslogOutputElement = document.getElementById('syslog-output-raw');
            this.copySyslogButton = document.getElementById('copy-syslog-button');
            this.clearSyslogButton = document.getElementById('clear-syslog-button');

            this.cliHistory = []; this.cliHistoryIndex = -1;
            this.isFullFrame = false; // Placeholder for potential future full-frame mode.

            // Verify all essential UI elements are present.
            let allElementsFound = true;
            const elementsToCheck = { 
                consoleRoot: this.consoleRootElement, visToggleBtn: this.visibilityToggleButton, 
                report: this.reportElement,selfCheckBtn: this.runCoreSelfCheckButton, 
                targetTestBtn: this.runTargetSystemTestsButton, copyBtn: this.copyReportButton,
                inspectorTab: this.toolTabButtons.inspector, cliTab: this.toolTabButtons.cli, 
                testsTab: this.toolTabButtons.tests, syslogTab: this.toolTabButtons.syslog,
                inspectorPane: this.toolPanes.inspector, cliPane: this.toolPanes.cli, 
                testsPane: this.toolPanes.tests, syslogPane: this.toolPanes.syslog,
                cliInput: this.cliInputElement, cliExec: this.cliExecuteButton, cliOut: this.cliOutputElement,
                inspRefresh: this.refreshInspectorButton, inspOut: this.inspectorOutputElement,
                syslogOut: this.syslogOutputElement, copySyslogBtn: this.copySyslogButton, clearSyslogBtn: this.clearSyslogButton
            };
            for (const key in elementsToCheck) { 
                if (!elementsToCheck[key]) { 
                    console.error(`Constructor Initialization ERROR: UI Element for '${key}' not found.`); 
                    allElementsFound = false; 
                } 
            }
            if (!allElementsFound) { 
                if(this.reportElement) this._logToReport("ERROR: Critical console UI elements were not found during initialization.", 'error'); 
                this._isInitialized = false; 
                return; 
            }
            
            this._isConsoleVisible = this.options.initialConsoleVisible;
            this._activeToolId = this.options.defaultTool;

            this._applyMinimalBaseStylesToCoreStructure();
            this._applyConsoleVisibility(); 
            this._setActiveTool(this._activeToolId);

            // Bind event listeners for all interactive console elements.
            this._bindCoreControls(); 
            this._bindVisibilityControls(); 
            this._bindToolTabControls(); 
            this._bindCliControls(); 
            this._bindInspectorControls();
            this._bindSyslogControls();
            this._bindFullFrameButtons(); // Currently a no-op, placeholder for future.
            
            this._isInitialized = true; 
            if (this._activeToolId === 'inspector') this.refreshInspector(); // Initial refresh if inspector is default.
            this._logToReport("RawCoreTester initialization complete and operational.", 'info');
            console.log("RawCoreTester: Constructor finished successfully.");
        }
        
        /**
         * Overrides native console methods (log, warn, error, info, debug) to capture
         * their output for display in the System Log tab.
         * The original console functionality is preserved.
         * For an LLM: This is the mechanism for intercepting all standard console messages.
         * It affects global `console` object behavior after `RawCoreTester` initializes.
         */
        _overrideConsoleMethods() {
            const consoleMethodsToOverride = ['log', 'warn', 'error', 'info', 'debug'];
            consoleMethodsToOverride.forEach(methodName => {
                if (typeof console[methodName] === 'function') {
                    this._originalConsole[methodName] = console[methodName].bind(console); // Store original method.
                    
                    console[methodName] = (...args) => {
                        // Call the original native console method to maintain normal browser console behavior.
                        this._originalConsole[methodName](...args); 
                        
                        // Format and store the message for the System Log tab.
                        const timestamp = new Date().toLocaleTimeString([], { hour12: false, hour: '2-digit', minute: '2-digit', second: '2-digit' });
                        let messageParts = [];
                        for (const arg of args) {
                            if (typeof arg === 'object' && arg !== null) {
                                try {
                                    if (arg instanceof Error) { // Special handling for Error objects to include stack.
                                        messageParts.push(`Error: ${arg.message}${arg.stack ? `\n${arg.stack}` : ''}`);
                                    } else { // Attempt to stringify other objects.
                                        messageParts.push(JSON.stringify(arg)); 
                                    }
                                } catch (e) {
                                    messageParts.push('[Unserializable Object]');
                                }
                            } else if (typeof arg === 'string'){
                                messageParts.push(arg);
                            } else {
                                messageParts.push(String(arg));
                            }
                        }
                        const formattedMessage = `[${timestamp}] [${methodName.toUpperCase()}] ${messageParts.join(' ')}`;
                        
                        this._capturedConsoleLogs.push(formattedMessage);
                        // Limit the number of stored logs to prevent memory issues.
                        if (this._capturedConsoleLogs.length > this.options.maxCapturedLogs) { 
                            this._capturedConsoleLogs.shift();
                        }

                        // If the System Log tab is currently active and UI is ready, refresh its content.
                        if (this._isInitialized && this._activeToolId === 'syslog' && this.syslogOutputElement) {
                            this._renderCapturedConsoleLogs();
                        }
                    };
                }
            });
        }

        /**
         * Renders the captured console logs into the System Log tab's output area.
         */
        _renderCapturedConsoleLogs() {
            if (!this.syslogOutputElement) return;
            this.syslogOutputElement.innerHTML = ''; // Clear previous logs.
            this._capturedConsoleLogs.forEach(logEntry => {
                const div = document.createElement('div');
                div.style.whiteSpace = 'pre-wrap'; // Preserve whitespace and newlines.
                div.textContent = logEntry;
                this.syslogOutputElement.appendChild(div);
            });
            // Scroll to the bottom to show the latest logs.
            this.syslogOutputElement.scrollTop = this.syslogOutputElement.scrollHeight;
        }
        
        /**
         * Applies minimal inline styles to the core HTML structure of the console
         * for basic layout and readability, without relying on external CSS.
         * @private
         */
        _applyMinimalBaseStylesToCoreStructure() { if(this.consoleRootElement)this.consoleRootElement.style.border="1px solid #777";const tA=document.getElementById('console-tool-tabs-area');if(tA){tA.style.borderBottom="1px solid #777";tA.style.marginBottom="5px";tA.style.paddingBottom="3px";}const cA=document.getElementById('console-tool-content-area');if(cA)cA.style.paddingTop="5px";if(this.toolPanes){Object.values(this.toolPanes).forEach(p=>{if(p)Object.assign(p.style,{padding:"5px",borderTop:"1px dashed #eee",minHeight:"50px",hidden:true});else console.error("BaseStyles: A tool pane element is null.");});}else{console.error("BaseStyles: toolPanes object is null.");}if(this.reportElement)Object.assign(this.reportElement.style,{border:"1px solid #ccc",minHeight:"100px",maxHeight:"250px",overflowY:"auto",background:"#f9f9f9",padding:"3px"});if(this.cliOutputElement)Object.assign(this.cliOutputElement.style,{border:"1px solid #ccc",minHeight:"50px",maxHeight:"150px",overflowY:"auto",background:"#fff",padding:"3px",marginBottom:"3px",whiteSpace:"pre-wrap"});if(this.inspectorOutputElement)Object.assign(this.inspectorOutputElement.style,{border:"1px solid #ccc",minHeight:"50px",maxHeight:"150px",overflowY:"auto",background:"#fff",padding:"3px",whiteSpace:"pre-wrap"});const cIC=document.getElementById('cli-input-container-raw');if(cIC)cIC.style.display="flex";if(this.cliInputElement)this.cliInputElement.style.flexGrow="1"; if(this.syslogOutputElement)Object.assign(this.syslogOutputElement.style,{border:"1px solid #ccc",minHeight:"100px",maxHeight:"250px",overflowY:"auto",background:"#f0f0f0",padding:"3px" /* font family set via inline style in HTML */});}
        
        /**
         * Logs a message to the test report area in the "Tests" tab.
         * @param {string} message - The message to log.
         * @param {string} [type='info'] - The type of message ('info', 'pass', 'fail', 'error', 'header').
         * @private
         */
        _logToReport(m,t='info'){if(!this.reportElement){console.log(`[Report Log Attempt - ${t}]:${m} (Report element not available)`);return}const e=document.createElement('div');let pr="";if(t==='pass')pr="✅ ";else if(t==='fail')pr="❌ ";else if(t==='error')pr="💥 ERROR: ";else if(t==='header')pr="--- ";e.textContent=pr+m;this.reportElement.appendChild(e);e.scrollIntoView({behavior:"auto",block:"end"});}
        
        /**
         * Asserts a condition within a test. Logs a pass or fail message to the report.
         * @param {boolean} condition - The condition to assert.
         * @param {string} successMessage - Message to log if the condition is true.
         * @param {string} failureMessage - Message to log if the condition is false.
         * @returns {boolean} True if the condition is met, false otherwise.
         * @private
         */
        _assert(c,sm,fm){if(!this._isInitialized&&this.reportElement){this._logToReport("Assertion attempted before full initialization.",'error');}if(c){this._logToReport(`  ${sm}`,'pass');return true;}else{this._logToReport(`  ${fm}`,'fail');return false;}}
        
        /**
         * Defines a test to be run by the test runner.
         * For an LLM: This is the primary method for adding automated tests.
         * Tests consist of a name and an array of asynchronous step functions.
         * @param {string} name - The name of the test.
         * @param {Array<Function>} stepsArray - An array of asynchronous functions representing test steps. Each step should return a boolean (true for pass).
         * @param {boolean} [isCritical=false] - Whether the test is critical (failure might halt further critical tests, though not implemented yet).
         * @param {string} [testType='target'] - The type of test ('target' for testing the target system, 'selfCheck' for testing the console itself).
         */
        defineTest(n,sA,cr=false,tT='target'){if(!this._isInitialized&&tT!=='selfCheckDuringInit'){this._logToReport(`Warning: Test '${n}' defined before tester was fully initialized.`,'error');}const tC=(tT==='selfCheck'||tT==='selfCheckDuringInit')?this.selfCheckTests:this.tests;if(!Array.isArray(tC)){this._logToReport(`CRITICAL ERROR: Test collection for type '${tT}' (test: '${n}') is not available.`,'error');return;}console.log(`Defining ${tT} test: ${n}`);tC.push({name:n,steps:sA,passed:false,critical:cr});}
        
        /**
         * Runs a single test, executing its steps sequentially.
         * @param {object} testObject - The test object (containing name, steps, etc.).
         * @param {object} systemToTest - The system instance to pass to test steps (either `this` for self-checks or `this.targetSystemUnderTest`).
         * @returns {Promise<boolean>} True if the test passed, false otherwise.
         * @private
         */
        async _runSingleTest(t,sTT){if(!this._isInitialized&&this.reportElement){this._logToReport(`Skipping test "${t.name}" - tester is not fully initialized.`,'error');return false;}this._logToReport(`Running test: ${t.name}${t.critical?' (CRITICAL)':''}...`);t.passed=true;try{for(const s of t.steps){await new Promise(r=>setTimeout(r,5)); /* Small delay for UI updates */ const sP=await s.call(this,sTT);if(!sP){t.passed=false;}}}catch(e){this._logToReport(`  UNHANDLED ERROR in test "${t.name}": ${e.message}\n${e.stack||''}`,'fail');console.error(`Unhandled error in test "${t.name}":`,e);t.passed=false;}if(t.passed){this._logToReport(`Test "${t.name}" PASSED.\n`,'pass');}else{this._logToReport(`Test "${t.name}" FAILED.\n`,'fail');}return t.passed;}
        
        /**
         * Runs all defined tests of a specific type ('target' or 'selfCheck').
         * @param {string} [testType='target'] - The type of tests to run.
         */
        async runTests(tT='target'){if(!this._isInitialized&&tT!=='selfCheck'){this._logToReport("Cannot run target system tests: Tester is not fully initialized.",'error');return;}this._setActiveTool('tests');await new Promise(r=>setTimeout(r,10)); /* Ensure UI updates before heavy processing */ const tC=(tT==='selfCheck')?this.selfCheckTests:this.tests;const sTT=(tT==='selfCheck')?this:this.targetSystemUnderTest;const tit=(tT==='selfCheck')?"Console Core Self-Check":"Target System Tests";if(this.reportElement&&((tT==='selfCheck'&&this.reportElement.textContent.split("--- Console Core Self-Check ---").length>1)||(tT==='target'&&this.reportElement.textContent.split("--- Target System Tests ---").length>1))){this.reportElement.innerHTML=this.initialReportPlaceholder;}this._logToReport(`\n${tit}`,'header');if(!Array.isArray(tC)||tC.length===0){this._logToReport("No tests defined for this category.",'info');this._logToReport(`End of ${tit}\n`,'header');return;}for(const t of tC){t.passed=false;}let tPC=0;for(const t of tC){if(await this._runSingleTest(t,sTT)){tPC++;}}this._logToReport(`\n${tit} Summary`,'header');this._logToReport(`Total tests run: ${tC.length}`);this._logToReport(`Passed: ${tPC}`,tPC===tC.length&&tC.length>0?'pass':'');this._logToReport(`Failed: ${tC.length-tPC}`,(tC.length-tPC)>0?'fail':'');this._logToReport(`End of ${tit}\n`,'header');}
        
        /**
         * Copies the content of the test report area to the clipboard.
         */
        copyReportToClipboard(){if(!this._isInitialized){alert("Console is not initialized. Cannot copy report.");return;}if(!this.reportElement){this._logToReport("ERROR: Report element is not available for copying.",'error');return;}const rT=this.reportElement.innerText||this.reportElement.textContent;const tRT=rT.trim();if(!tRT||tRT===this.initialReportPlaceholder.trim()){this._logToReport("Report is empty or contains only placeholder text. Nothing to copy.",'info');return;}navigator.clipboard.writeText(rT).then(()=>{this._logToReport("Report copied to clipboard!",'info');if(this.copyReportButton){const oT=this.copyReportButton.textContent;this.copyReportButton.textContent="Copied!";setTimeout(()=>{if(this.copyReportButton)this.copyReportButton.textContent=oT;},1500);}}).catch(err=>{this._logToReport(`ERROR: Failed to copy report to clipboard: ${err.message}`,'error');try{const tA=document.createElement("textarea");tA.value=rT;tA.style.position="fixed";tA.style.opacity="0";document.body.appendChild(tA);tA.focus();tA.select();document.execCommand('copy');document.body.removeChild(tA);this._logToReport("Report copied to clipboard using fallback method.",'info');}catch(fErr){this._logToReport(`ERROR: Fallback copy method also failed: ${fErr.message}`,'error');alert("Could not copy report to clipboard.");}});}
        
        /**
         * Binds event listeners to core console controls (run tests, copy report).
         * @private
         */
        _bindCoreControls(){console.log("Binding core console control events.");if(this.runCoreSelfCheckButton)this.runCoreSelfCheckButton.addEventListener('click',()=>{console.log("Run Core Self-Check button clicked.");this.runTests('selfCheck');});if(this.runTargetSystemTestsButton)this.runTargetSystemTestsButton.addEventListener('click',()=>{console.log("Run Target System Tests button clicked.");if(!this.targetSystemUnderTest){this._logToReport("ERROR: No target system instance provided to test.",'error');return;}this.runTests('target');});if(this.copyReportButton)this.copyReportButton.addEventListener('click',()=>{console.log("Copy Report button clicked.");this.copyReportToClipboard();});}
        
        /**
         * Gets the initialization status of the console.
         * @returns {boolean} True if the console is fully initialized, false otherwise.
         */
        getInitializationStatus(){return this._isInitialized;}
        
        /** Example of an internal helper function, potentially for use in self-checks or complex operations. @private */
        _internalHelperFunction(a,b){return a+b;}

        /**
         * Applies the current visibility state to the console's root element.
         * @private
         */
        _applyConsoleVisibility(){if(!this.consoleRootElement){console.error("Cannot apply visibility: Console root element not found.");return;}this.consoleRootElement.hidden=!this._isConsoleVisible;if(this.visibilityToggleButton)this.visibilityToggleButton.textContent=this._isConsoleVisible?`Hide Console (${this.options.visibilityToggleKeystroke})`:`Show Console (${this.options.visibilityToggleKeystroke})`;console.log(`Console visibility updated. Hidden: ${this.consoleRootElement.hidden}`);}
        
        /**
         * Toggles the visibility of the entire diagnostic console.
         */
        toggleConsoleVisibility(){if(!this._isInitialized){ console.warn("Attempted to toggle visibility before console was initialized."); return; }this._isConsoleVisible=!this._isConsoleVisible;this._applyConsoleVisibility();}
        
        /**
         * Binds event listeners for console visibility controls (toggle button, keystroke).
         * @private
         */
        _bindVisibilityControls(){console.log("Binding visibility control events.");if(this.visibilityToggleButton){this.visibilityToggleButton.addEventListener('click',()=>{console.log("Visibility Toggle Button clicked.");this.toggleConsoleVisibility();});}document.addEventListener('keydown',(event)=>{if(!this.options.visibilityToggleKeystroke)return;try{const parts=this.options.visibilityToggleKeystroke.split('+');const targetKeyInput=parts.pop().toLowerCase();const ctrl=parts.includes('Ctrl')||parts.includes('Control');const shift=parts.includes('Shift');const alt=parts.includes('Alt');let eventKeyComparable=event.key.toLowerCase();if(event.key==='`'&&targetKeyInput==='backquote'){eventKeyComparable='backquote';}if((eventKeyComparable===targetKeyInput||(event.code&&event.code.toLowerCase().replace('key','')===targetKeyInput))&&event.ctrlKey===ctrl&&event.shiftKey===shift&&event.altKey===alt){event.preventDefault();console.log(`Visibility Keystroke '${this.options.visibilityToggleKeystroke}' detected (event.key: '${event.key}', event.code: '${event.code}')`);this.toggleConsoleVisibility();}}catch(e){console.error("Error processing keystroke for visibility toggle:",e);}}); }
        
        /** Gets the current visibility state of the console. @returns {boolean} */
        getConsoleVisibility(){return this._isConsoleVisible;}

        /**
         * Binds event listeners to tool tab buttons for switching between console panes.
         * @private
         */
        _bindToolTabControls(){console.log("Binding tool tab control events.");Object.values(this.toolTabButtons).forEach(btn=>{if(btn)btn.addEventListener('click',()=>this._setActiveTool(btn.dataset.tool));});}
        
        /**
         * Sets the active tool pane, showing the selected pane and hiding others.
         * @param {string} toolId - The ID of the tool to activate ('inspector', 'cli', 'tests', 'syslog').
         * @private
         */
        _setActiveTool(tId){if(!tId||!this.toolPanes[tId]){console.warn(`Attempted to activate invalid or missing tool ID: ${tId}. Falling back to default.`);tId=this.options.defaultTool||Object.keys(this.toolPanes)[0];if(!tId||!this.toolPanes[tId]){this._logToReport(`CRITICAL ERROR: No valid tool could be activated. Default tool also invalid.`,'error');console.error("No valid tool could be activated.");return;}}console.log(`Activating tool: ${tId}`);this._activeToolId=tId;Object.keys(this.toolPanes).forEach(id=>{if(this.toolPanes[id]){this.toolPanes[id].hidden=(id!==tId);}});Object.keys(this.toolTabButtons).forEach(id=>{if(this.toolTabButtons[id])this.toolTabButtons[id].textContent=(id===tId)?`*${this.toolTabButtons[id].dataset.tool}*` : this.toolTabButtons[id].dataset.tool.replace(" Tab", "") + " Tab";});if(tId==='inspector'&&typeof this.refreshInspector==='function')this.refreshInspector(); if(tId==='syslog' && typeof this._renderCapturedConsoleLogs === 'function') this._renderCapturedConsoleLogs();}
        
        /** Gets the ID of the currently active tool pane. @returns {string} */
        getActiveToolId(){return this._activeToolId;}
            
        /**
         * Refreshes the content of the Object Inspector pane.
         * It rebuilds the tree view of the `targetSystemUnderTest`.
         */
        refreshInspector() { if (!this.inspectorOutputElement) { console.warn("Inspector output element not available for refresh."); return; } if (!this.targetSystemUnderTest) { this.inspectorOutputElement.textContent = "Target system instance is not available."; return; } console.log("Refreshing Inspector view."); this.inspectorOutputElement.innerHTML = ''; try { const treeRoot = this._buildInspectorTree(this.targetSystemUnderTest, 'system', 0, new Set()); this.inspectorOutputElement.appendChild(treeRoot); } catch (e) { this.inspectorOutputElement.textContent = `Error building inspector tree: ${e.message}`; console.error("Error during inspector tree construction:", e); } }
        
        /**
         * Recursively builds the HTML tree structure for the Object Inspector.
         * @param {any} obj - The current object/value to inspect.
         * @param {string} keyName - The name of the property being inspected.
         * @param {number} depth - The current recursion depth.
         * @param {Set} visitedObjects - A set to track visited objects for circular reference detection.
         * @returns {HTMLElement} The HTML div element representing this node in the tree.
         * @private
         */
        _buildInspectorTree(obj, keyName, depth, visitedObjects) { const entryDiv = document.createElement('div'); entryDiv.innerHTML = ' '.repeat(depth * 4); /* Indentation */ const type = typeof obj; let summaryBaseText = `${keyName}: `; const summarySpan = document.createElement('span'); /* console.log(`InspectorTree: Building node - depth=${depth}, key=${keyName}, type=${type}`); */ if (obj === null) { summarySpan.textContent = summaryBaseText + "null"; entryDiv.appendChild(summarySpan); } else if (type === 'undefined') { summarySpan.textContent = summaryBaseText + "undefined"; entryDiv.appendChild(summarySpan); } else if (type === 'string') { summarySpan.textContent = summaryBaseText + `"${obj}"`; entryDiv.appendChild(summarySpan); } else if (type === 'number' || type === 'boolean') { summarySpan.textContent = summaryBaseText + String(obj); entryDiv.appendChild(summarySpan); } else if (type === 'function') { summarySpan.textContent = summaryBaseText + `[Function: ${obj.name || 'anonymous'}]`; entryDiv.appendChild(summarySpan); } else if (type === 'object') { if (visitedObjects.has(obj)) { summarySpan.textContent = summaryBaseText + "[Circular Reference]"; entryDiv.appendChild(summarySpan); return entryDiv; } visitedObjects.add(obj); const isArray = Array.isArray(obj); summaryBaseText += isArray ? `Array(${obj.length})` : `Object`; summarySpan.textContent = summaryBaseText + ' (+)'; summarySpan.title = "Click to expand/collapse"; summarySpan.setAttribute('role', 'button'); summarySpan.setAttribute('tabindex', '0'); summarySpan.style.cursor = 'pointer'; summarySpan.style.textDecoration = 'underline'; const childrenContainer = document.createElement('div'); childrenContainer.hidden = true; const toggleChildren = (e) => { e.stopPropagation(); childrenContainer.hidden = !childrenContainer.hidden; summarySpan.textContent = `${summaryBaseText} ${childrenContainer.hidden ? '(+)' : '(-)'}`; console.log(`InspectorTree: Toggled node '${keyName}', children visibility: ${!childrenContainer.hidden}`); }; summarySpan.addEventListener('click', toggleChildren); summarySpan.addEventListener('keydown', (e) => { if (e.key === 'Enter' || e.key === ' ') { e.preventDefault(); toggleChildren(e); } }); entryDiv.appendChild(summarySpan); entryDiv.appendChild(childrenContainer); if (depth < this.options.inspectorMaxDepth) { let keysToShow = Object.getOwnPropertyNames(obj); if (!isArray) { let proto = Object.getPrototypeOf(obj); let pD=0; const maxPD=1; /* Limit prototype chain walk */ while(proto && proto !== Object.prototype && pD < maxPD){ Object.getOwnPropertyNames(proto).forEach(pK=>{if(typeof obj[pK]==='function'&&!keysToShow.includes(pK)&&pK!=='constructor' && !Object.prototype.hasOwnProperty.call(Object.prototype, pK) )keysToShow.push(pK);}); proto=Object.getPrototypeOf(proto);pD++;}} keysToShow.sort(); if (keysToShow.length === 0 && !isArray && Object.keys(obj).length === 0) { const eD=document.createElement('div');eD.innerHTML=' '.repeat((depth+1)*4)+'(empty object)';childrenContainer.appendChild(eD); } else if (isArray && keysToShow.length === 0) { const eD=document.createElement('div');eD.innerHTML=' '.repeat((depth+1)*4)+'(empty array)';childrenContainer.appendChild(eD); } else { for (const key of keysToShow) { if (key.startsWith('_')&&key!=='__proto__') continue; /* Optionally hide private-like properties */ if (key==='constructor'&&typeof obj[key]==='function') continue; try { childrenContainer.appendChild(this._buildInspectorTree(obj[key], key, depth + 1, new Set(visitedObjects))); } catch (e) { const errD=document.createElement('div');errD.textContent=`${key}:[Error Accessing Property]`;errD.innerHTML=' '.repeat((depth+1)*4)+errD.textContent;childrenContainer.appendChild(errD);}}}} else { const mDD=document.createElement('div');mDD.textContent="(Max inspection depth reached)";mDD.innerHTML=' '.repeat((depth+1)*4)+mDD.textContent;childrenContainer.appendChild(mDD);} visitedObjects.delete(obj); /* Clean up for siblings at same level */ } else { summarySpan.textContent = summaryBaseText + `[Unknown Type: ${type}]`; entryDiv.appendChild(summarySpan); } return entryDiv; }
        
        /**
         * Binds event listener for the "Refresh Inspector" button.
         * @private
         */
        _bindInspectorControls(){console.log("Binding Inspector control events.");if(this.refreshInspectorButton){this.refreshInspectorButton.addEventListener('click',()=>{console.log("Refresh Inspector button clicked.");this.refreshInspector();});}}
        
        /**
         * Logs a message to the CLI output area.
         * @param {string} message - The message to log.
         * @param {string} [type='info'] - Type of message ('info', 'error', 'input').
         * @private
         */
        _logToCli(m,t='info') { if(!this.cliOutputElement){console.warn("CLI output element not available:",m);return;} const e=document.createElement('div');let pr="";if(t==='error')pr="Error: ";else if(t==='input')pr="> ";e.textContent=pr+m;this.cliOutputElement.appendChild(e);this.cliOutputElement.scrollTop=this.cliOutputElement.scrollHeight;}
        
        /**
         * Parses a string argument from the CLI input into its corresponding JavaScript type.
         * Supports numbers, booleans, null, and quoted strings.
         * @param {string} argString - The argument string to parse.
         * @returns {any} The parsed argument.
         * @throws {Error} If the argument string cannot be recognized.
         * @private
         */
        _parseCliArgument(aS){aS=aS.trim();if(!isNaN(aS)&&aS!=='')return parseFloat(aS);if(aS.toLowerCase()==='true')return true;if(aS.toLowerCase()==='false')return false;if(aS.toLowerCase()==='null')return null;if((aS.startsWith('"')&&aS.endsWith('"'))||(aS.startsWith("'")&&aS.endsWith("'"))){try{const i=aS.slice(1,-1);return JSON.parse(`"${i.replace(/"/g,'\\"')}"`);}catch(e){/* Fallback for strings that might not be valid JSON after escaping, e.g. containing only single quotes internally */ return aS.slice(1,-1);}}this._logToCli(`Unrecognized argument format: ${aS}. Arguments must be numbers, booleans (true/false), null, or strings enclosed in single/double quotes.`,'error');throw new Error(`Unrecognized argument: ${aS}`);}
        
        /**
         * Executes a command entered into the CLI.
         * Commands are expected to be in the format `system.method(args)` or `system.property`.
         * For an LLM: This method interprets user input to interact with `this.targetSystemUnderTest`.
         */
        executeCliCommand(){if(!this.cliInputElement||!this.targetSystemUnderTest){this._logToCli("CLI or target system is not ready for command execution.","error");return;}const cS=this.cliInputElement.value.trim();if(!cS)return;this._logToCli(cS,'input');if(this.cliHistory.length===0||this.cliHistory[this.cliHistory.length-1]!==cS){this.cliHistory.push(cS);if(this.cliHistory.length>30)this.cliHistory.shift(); /* Limit history size */}this.cliHistoryIndex=this.cliHistory.length;this.cliInputElement.value='';try{const sys=this.targetSystemUnderTest;let res;const methodCallRegex=/^system\.([a-zA-Z_]\w*)\s*\((.*)\)$/;const propertyAccessRegex=/^system\.([a-zA-Z_]\w*)$/;let match;if((match=methodCallRegex.exec(cS))!==null){const methodName=match[1];const argsString=match[2].trim();let args=[];if(argsString){const argParts=argsString.split(',').map(a=>a.trim()).filter(a=>a!=='');args=argParts.map(aS=>this._parseCliArgument(aS));}if(typeof sys[methodName]==='function'){res=sys[methodName](...args);this._logToCli(`Method '${methodName}' executed. Arguments: [${args.join(', ')}]`);}else{throw new Error(`Method '${methodName}' not found on the target system.`);}}else if((match=propertyAccessRegex.exec(cS))!==null){const propName=match[1];if(propName in sys){if(typeof sys[propName]==='function'&&!cS.includes('(')){ /* Property is a function but not called as one */ throw new Error(`Property '${propName}' is a method. To call it, use parentheses, e.g., system.${propName}()`);}else{res=sys[propName];}}else{throw new Error(`Property '${propName}' not found on the target system.`);}this._logToCli(`Accessed property '${propName}'.`);}else{throw new Error("Invalid command format. Use 'system.method(args)' or 'system.property'.");}if(res!==undefined){this._logToCli(typeof res==='object'?JSON.stringify(res,null,2):String(res));}else{this._logToCli(`(Command executed, no return value or undefined)`);}}catch(e){this._logToCli(`${e.message}`,'error'); /* Error logged to CLI output, not browser console */ }}
        
        /**
         * Navigates through the CLI command history (up/down arrow keys).
         * @param {number} direction - -1 for previous, 1 for next.
         * @private
         */
        _navigateCliHistory(d){if(!this.cliInputElement||this.cliHistory.length===0)return;const nI=this.cliHistoryIndex+d;if(nI>=0&&nI<this.cliHistory.length){this.cliHistoryIndex=nI;this.cliInputElement.value=this.cliHistory[this.cliHistoryIndex];}else if(nI===this.cliHistory.length||(nI<0&&d===1)){this.cliHistoryIndex=this.cliHistory.length;this.cliInputElement.value='';}else if(nI<0&&d===-1){this.cliHistoryIndex=0;this.cliInputElement.value=this.cliHistory[0];}if(this.cliInputElement)this.cliInputElement.setSelectionRange(this.cliInputElement.value.length,this.cliInputElement.value.length); /* Move cursor to end */}
        
        /**
         * Binds event listeners for CLI controls (execute button, input field for Enter/Arrow keys).
         * @private
         */
        _bindCliControls(){console.log("Binding CLI control events.");if(this.cliExecuteButton&&this.cliInputElement){this.cliExecuteButton.addEventListener('click',()=>{console.log("CLI Execute button clicked.");this.executeCliCommand();});this.cliInputElement.addEventListener('keydown',(event)=>{if(event.key==='Enter'){event.preventDefault();this.executeCliCommand();}else if(event.key==='ArrowUp'){event.preventDefault();this._navigateCliHistory(-1);}else if(event.key==='ArrowDown'){event.preventDefault();this._navigateCliHistory(1);}});}}
            
        /**
         * Binds event listeners for System Log controls (copy, clear).
         * @private
         */
        _bindSyslogControls() {
            console.log("Binding System Log control events.");
            if (this.copySyslogButton) {
                this.copySyslogButton.addEventListener('click', () => {
                    console.log("Copy System Log button clicked.");
                    if (!this._isInitialized) { alert("Console not initialized."); return; }
                    if (!this.syslogOutputElement || this._capturedConsoleLogs.length === 0) {
                        this._logToReport("System log is empty. Nothing to copy.", 'info');
                        return;
                    }
                    const logText = this._capturedConsoleLogs.join('\n');
                    navigator.clipboard.writeText(logText)
                        .then(() => { 
                            this._logToReport("System log copied to clipboard!", 'info');
                            const originalText = this.copySyslogButton.textContent;
                            this.copySyslogButton.textContent = "Copied!";
                            setTimeout(() => { if(this.copySyslogButton) this.copySyslogButton.textContent = originalText; }, 1500);
                        })
                        .catch(err => {
                                this._logToReport(`ERROR: System log copy failed: ${err.message}`, 'error');
                            try { // Fallback for environments where clipboard API might fail (e.g., insecure contexts)
                                const tA = document.createElement("textarea");
                                tA.value = logText;
                                tA.style.position = "fixed"; tA.style.opacity = "0"; // Make invisible
                                document.body.appendChild(tA);
                                tA.focus(); tA.select(); document.execCommand('copy');
                                document.body.removeChild(tA);
                                this._logToReport("System log copied to clipboard (fallback method).", 'info');
                            } catch (fErr) {
                                this._logToReport(`ERROR: System log fallback copy method also failed: ${fErr.message}`, 'error');
                                alert("Could not copy system log to clipboard.");
                            }
                        });
                });
            }
            if (this.clearSyslogButton) {
                this.clearSyslogButton.addEventListener('click', () => {
                    console.log("Clear System Log button clicked.");
                    if (!this._isInitialized) { alert("Console not initialized."); return; }
                    this._capturedConsoleLogs = [];
                    if (this.syslogOutputElement) this.syslogOutputElement.innerHTML = 'Captured system console logs will appear here...';
                    this._logToReport("System log cleared.", 'info'); 
                });
            }
        }

        // Placeholder methods for potential future enhancements (e.g., draggable/resizable console).
        /** @private */ _bindFullFrameButtons(){console.log("Binding full-frame button events (currently no-op)."); }
        /** @private */ _toggleFullFrame(){this._logToReport("Full-frame mode is not implemented.",'info');}
    }

    /**
     * A mock calculator class serving as an example target system for `RawCoreTester`.
     * It has properties and methods that can be inspected and called via the diagnostic console.
     * For an LLM: This demonstrates the type of object `RawCoreTester` is designed to work with.
     */
    class MockCalculator { 
        constructor(displayElementId){
            this.currentValue = 0;
            this.displayElement = document.getElementById(displayElementId);
            this.calculatorName = "CalcInstance";
            this._internalSecret = "_secret_value_not_for_direct_display"; // Example of a "private-like" property
            this.updateDisplay();
            console.log("MockCalculator instance created.");
        }
        add(number){
            console.log(`MockCalculator.add(${number}) called. Current value: ${this.currentValue}`);
            this.currentValue += number;
            this.updateDisplay();
            return this.currentValue;
        }
        getValue(){
            console.log("MockCalculator.getValue() called.");
            return this.currentValue;
        }
        updateDisplay(){
            if(this.displayElement) this.displayElement.textContent = `Calc Val: ${this.currentValue}`; 
        }
        reset(){
            console.log("MockCalculator.reset() called.");
            this.currentValue = 0;
            this.updateDisplay();
        }
        complexArgumentTest(num, str, boolVal){
            console.log(`MockCalculator.complexArgumentTest received: number ${num}, string "${str}", boolean ${boolVal}`);
            return`Received: number ${num}, string "${str}", boolean ${boolVal}`;
        }
    }
    MockCalculator.prototype.protoMethod = function() { return "This is a method from the prototype."; };

    // Event listener to initialize the RawCoreTester when the DOM is fully loaded.
    document.addEventListener('DOMContentLoaded', () => {
        // This initial console.log may or may not be captured by RawCoreTester's syslog,
        // depending on the exact timing of its constructor and the _overrideConsoleMethods call.
        // Subsequent logs within this block, after RawCoreTester is instantiated, WILL be captured.
        console.log("DOMContentLoaded: Initializing application and diagnostic console.");
        
        const myCalculator = new MockCalculator('calculator-display');
        // Add some complex properties for testing the inspector
        myCalculator.nestedObject = { 
            level1: { 
                level2: { 
                    level3: { 
                        level4Value: "Reached deep level"
                    }
                }, 
                anotherProperty: "Sibling property at level 1"
            }
        };
        myCalculator.circularReference = myCalculator; // For testing circular reference handling

        const coreTester = new RawCoreTester(myCalculator, 'console-test-report-area', {
            initialConsoleVisible: true, 
            defaultTool: 'inspector',
            visibilityToggleKeystroke: 'Control+Backquote', // Example: Ctrl + `
            inspectorMaxDepth: 3 
        });

        if (!coreTester || !coreTester.getInitializationStatus()) { 
            console.error("FATAL: RawCoreTester initialization failed. Check console for details."); 
            const reportArea = document.getElementById('console-test-report-area');
            if(reportArea) reportArea.innerHTML += "<p><strong>FATAL: RawCoreTester failed initialization. Diagnostics may be unavailable.</strong></p>";
            return; 
        }
        
        // --- Define Self-Check Tests for the RawCoreTester itself ---
        coreTester.defineTest( "SC: Console Initialization and Panes", [
            async function(self){ return this._assert(self.getInitializationStatus() === true, "Console initialized successfully.", "Console FAILED to initialize.")},
            async function(self){ 
                const defaultTool = self.options.defaultTool; 
                self._setActiveTool(defaultTool); 
                await new Promise(r => setTimeout(r, 20)); // Allow UI to update
                const displayStyle = self.toolPanes[defaultTool] ? self.toolPanes[defaultTool].hidden : true;
                return this._assert(displayStyle === false, `Default tool pane '${defaultTool}' is visible.`, `Default tool pane '${defaultTool}' is NOT visible.`);
            }
        ],true,'selfCheck');

        coreTester.defineTest( "SC: Tool Pane Switching", [
            async function(self){
                let pass = true;
                self._setActiveTool('inspector'); await new Promise(r => setTimeout(r, 10));
                pass = pass && this._assert(self.getActiveToolId()==='inspector',"Switched to Inspector tab.","Failed to switch to Inspector tab.");
                pass = pass && this._assert(self.toolPanes.inspector && !self.toolPanes.inspector.hidden,"Inspector pane is visible.","Inspector pane is NOT visible.");
                pass = pass && this._assert(self.toolPanes.cli && self.toolPanes.cli.hidden,"CLI pane is hidden.","CLI pane is NOT hidden when Inspector active.");
                
                self._setActiveTool('cli'); await new Promise(r => setTimeout(r, 10));
                pass = pass && this._assert(self.getActiveToolId()==='cli',"Switched to CLI tab.","Failed to switch to CLI tab.");
                pass = pass && this._assert(self.toolPanes.cli && !self.toolPanes.cli.hidden,"CLI pane is visible.","CLI pane is NOT visible.");
                pass = pass && this._assert(self.toolPanes.inspector && self.toolPanes.inspector.hidden,"Inspector pane is hidden.","Inspector pane is NOT hidden when CLI active.");

                self._setActiveTool('syslog'); await new Promise(r => setTimeout(r, 10));
                pass = pass && this._assert(self.getActiveToolId()==='syslog',"Switched to System Log tab.","Failed to switch to System Log tab.");
                pass = pass && this._assert(self.toolPanes.syslog && !self.toolPanes.syslog.hidden,"System Log pane is visible.","System Log pane is NOT visible.");
                return pass;
            }
        ],true,'selfCheck');
        
        coreTester.defineTest( "SC: Inspector Basic Tree Functionality", [ 
            async function(self) { 
                console.log("Inspector Self-Test: Verifying basic tree rendering and interaction.");
                if (!self.inspectorOutputElement) {
                    console.error("Inspector Self-Test ABORTED: inspectorOutputElement is not available.");
                    return this._assert(false,"","Inspector output element is missing, cannot run test.");
                }
                self._setActiveTool('inspector'); // This implicitly calls refreshInspector
                await new Promise(r => setTimeout(r, 50)); // Allow inspector to render

                const initialOutputHTML = self.inspectorOutputElement.innerHTML;
                let pass = this._assert(initialOutputHTML.includes("system: Object (+)") && initialOutputHTML.includes("currentValue:") && initialOutputHTML.includes("getValue:"), 
                                       "Inspector shows root object and some of its properties/methods.", 
                                       `Initial inspector HTML content is incorrect or missing expected items. HTML: ${initialOutputHTML.substring(0,200)}`);
                if (!pass) return false; // Critical first step
                
                const firstExpandable = self.inspectorOutputElement.querySelector('span[style*="cursor: pointer"]');
                if (!firstExpandable) {
                    return this._assert(false, "", "No expandable 'system' span found in inspector output.");
                }
                const childrenContainer = firstExpandable.nextElementSibling;
                if (!childrenContainer || childrenContainer.tagName !== 'DIV') {
                     return this._assert(false, "", "Children container div not found or is not a DIV, next to the expandable span.");
                }

                firstExpandable.click(); // Expand the node
                await new Promise(r => setTimeout(r, 50)); // Allow UI to update

                pass = pass && this._assert(childrenContainer.hidden === false, "Inspector node expanded successfully (children container is visible).", `Inspector node expansion failed - children container hidden state: ${childrenContainer.hidden}`);
                pass = pass && this._assert(firstExpandable.textContent.includes("(-)"), "Expand indicator correctly shows '(-)' after expansion.", `Expand indicator text is incorrect after expansion: ${firstExpandable.textContent}`);
                pass = pass && this._assert(childrenContainer.innerHTML.includes("currentValue:"), "Expanded view contains expected child property 'currentValue:'.", "Child property 'currentValue:' not found in expanded view.");

                firstExpandable.click(); // Collapse the node
                await new Promise(r => setTimeout(r, 50)); // Allow UI to update

                pass = pass && this._assert(childrenContainer.hidden === true, "Inspector node collapsed successfully (children container is hidden).", `Inspector node collapse failed - children container hidden state: ${childrenContainer.hidden}`);
                pass = pass && this._assert(firstExpandable.textContent.includes("(+)"), "Collapse indicator correctly shows '(+)' after collapse.", `Collapse indicator text is incorrect after collapse: ${firstExpandable.textContent}`);
                
                self.inspectorOutputElement.innerHTML = 'Inspector output...'; // Reset for subsequent tests or manual use
                return pass;
            }
        ], true, 'selfCheck');

        coreTester.defineTest( "SC: CLI Structured Execution", [
            async function(self) { 
                if(!self.cliInputElement||!self.cliExecuteButton||!self.cliOutputElement){return this._assert(false,"","CLI UI elements are missing, cannot run test.");} 
                self.targetSystemUnderTest.reset(); 
                let op, overallPass = true; 
                const execAndWait = async (cmd) => { 
                    if (self.cliOutputElement) self.cliOutputElement.innerHTML = ''; // Clear previous CLI output
                    self.cliInputElement.value = cmd; 
                    self.executeCliCommand(); 
                    await new Promise(r=>setTimeout(r,50)); // Allow command to process and UI to update
                    return self.cliOutputElement ? self.cliOutputElement.textContent : "CLI_OUTPUT_UNAVAILABLE"; 
                }; 
                
                op = await execAndWait('system.add(10)'); 
                let currentTestPass = this._assert(op.includes("Method 'add' executed")&&op.includes("10")&&self.targetSystemUnderTest.getValue()===10,"CLI: system.add(10) executed correctly.",`CLI: system.add(10) failed. Output:[${op}], Actual Value:${self.targetSystemUnderTest.getValue()}`); 
                if(!currentTestPass) overallPass = false; 
                
                op = await execAndWait('system.currentValue'); 
                currentTestPass = this._assert(op.includes("Accessed property 'currentValue'")&&op.includes("10"),"CLI: system.currentValue accessed correctly.",`CLI: system.currentValue failed. Output:[${op}]`); 
                if(!currentTestPass) overallPass = false; 
                
                op = await execAndWait('system.complexArgumentTest(123, "hello world", true)'); 
                currentTestPass = this._assert(op.includes('Received: number 123, string "hello world", boolean true'),"CLI: system.complexArgumentTest executed correctly with multiple argument types.",`CLI: system.complexArgumentTest failed. Output:[${op}]`); 
                if(!currentTestPass) overallPass = false; 
                
                op = await execAndWait('system.nonExistentMethod()'); 
                currentTestPass = this._assert(op.includes("Error: Method 'nonExistentMethod' not found on the target system."),"CLI: Handled non-existent method call correctly (error logged to CLI output).","CLI: Non-existent method call not handled as expected. Output:["+op+"]"); 
                if(!currentTestPass) overallPass = false; 
                
                if(self.cliOutputElement) self.cliOutputElement.innerHTML='CLI output...'; // Reset CLI output
                return overallPass; 
            }
        ],true,'selfCheck');

        coreTester.defineTest("SC: System Log Capture and Display", [
            async function(self){ 
                console.log("Syslog Self-Test: Logging a standard message."); 
                console.warn("Syslog Self-Test: Logging a warning message."); 
                await new Promise(r => setTimeout(r, 20)); // Allow logs to be captured
                
                const capturedLogs = self._capturedConsoleLogs;
                let pass = this._assert(capturedLogs.some(l => l.includes("[LOG] Syslog Self-Test: Logging a standard message.")), "Captured a standard console.log message.", "Failed to capture standard console.log message.");
                pass = pass && this._assert(capturedLogs.some(l => l.includes("[WARN] Syslog Self-Test: Logging a warning message.")), "Captured a console.warn message.", "Failed to capture console.warn message.");
                
                self._setActiveTool('syslog'); 
                await new Promise(r => setTimeout(r, 20)); // Allow syslog pane to render
                
                const syslogOutputContent = self.syslogOutputElement ? self.syslogOutputElement.textContent : "";
                pass = pass && this._assert(syslogOutputContent.includes("Syslog Self-Test: Logging a standard message.") && syslogOutputContent.includes("Syslog Self-Test: Logging a warning message."), "System Log pane displays captured logs correctly.", "System Log pane does not display captured logs as expected.");
                return pass;
            }
        ], true, 'selfCheck');

        // --- Define Target System Tests (for MockCalculator) ---
        coreTester.defineTest("Target: Calculator Initialization", [ 
            async function(calculatorInstance){
                calculatorInstance.reset(); 
                return this._assert(calculatorInstance.getValue()===0,"Calculator initializes/resets to 0.","Calculator did NOT initialize/reset to 0."); 
            } 
        ],true,'target');

        coreTester.defineTest("Target: Calculator Addition Logic", [
            async function(calculatorInstance){
                calculatorInstance.reset();
                calculatorInstance.add(5);
                return this._assert(calculatorInstance.getValue()===5,"Adding 5 results in 5.","Adding 5 did not result in 5.");
            },
            async function(calculatorInstance){
                calculatorInstance.add(10); // current value is 5, 5+10=15
                return this._assert(calculatorInstance.getValue()===15,"Adding 10 to 5 results in 15.","Adding 10 to 5 did not result in 15.");
            }
        ],false,'target');
            
        console.log("DOMContentLoaded: All initial setup and test definitions are complete.");
    });
    </script>
</body>
</html>
